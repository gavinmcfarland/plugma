name: Create release

on:
    push:
        tags:
            - 'v*' # Trigger on tags starting with 'v' (default format)
            - '*@*' # Trigger on tags with @ symbol (custom prefix format)

permissions:
    contents: write # Allow the workflow to push tags

jobs:
    release:
        runs-on: ubuntu-latest

        outputs:
            NEW_VERSION: ${{ steps.determine_release_type.outputs.new_version }} # Define NEW_VERSION as output

        steps:
            - name: Checkout repository
              uses: actions/checkout@v3
              with:
                  ref: main # Ensure you're checking out the main branch
                  tags: true

            - name: Fetch specific tag
              run: |
                  TAG_NAME="${{ github.ref }}"
                  TAG_NAME=${TAG_NAME#refs/tags/}
                  git fetch origin "refs/tags/$TAG_NAME:refs/tags/$TAG_NAME" # Fetch only the specific tag

            - name: Prepare environment
              run: |
                  # Enable corepack to handle package managers
                  corepack enable

                  # Check if package.json has a packageManager field
                  if [ -f package.json ]; then
                    echo "üìã Checking package.json for packageManager field..."
                    if grep -q '"packageManager"' package.json; then
                      PACKAGE_MANAGER=$(grep -o '"packageManager": "[^"]*"' package.json | cut -d'"' -f4 | cut -d'@' -f1)
                      echo "‚úÖ packageManager field found: $PACKAGE_MANAGER"
                    else
                      echo "‚ÑπÔ∏è  No packageManager field found - corepack may add one automatically"
                    fi
                  fi

                  # Show available lockfiles
                  echo "üîç Available lockfiles:"
                  if [ -f "pnpm-lock.yaml" ]; then echo "  ‚úÖ pnpm-lock.yaml"; fi
                  if [ -f "yarn.lock" ]; then echo "  ‚úÖ yarn.lock"; fi
                  if [ -f "package-lock.json" ]; then echo "  ‚úÖ package-lock.json"; fi

            - name: Detect package manager and install dependencies
              run: |
                  # Check packageManager field in package.json first
                  if [ -f "package.json" ]; then
                    PACKAGE_MANAGER=$(grep -o '"packageManager": "[^"]*"' package.json | cut -d'"' -f4 | cut -d'@' -f1)
                    if [ "$PACKAGE_MANAGER" = "pnpm" ]; then
                      echo "üì¶ Using pnpm (detected from packageManager field)"
                      # Try with frozen lockfile first, fallback to regular install if it fails
                      if ! pnpm install --frozen-lockfile; then
                        echo "‚ö†Ô∏è  Lockfile is out of sync, updating dependencies..."
                        pnpm install
                      fi

                      # Ensure plugma is installed locally (not linked globally)
                      echo "üì¶ Ensuring plugma is installed locally..."
                      PLUGMA_VERSION=$(grep -o '"plugma": "[^"]*"' package.json | cut -d'"' -f4)
                      if pnpm list plugma | grep -q "link:"; then
                        echo "‚ö†Ô∏è  plugma is linked globally, reinstalling locally..."
                        pnpm remove plugma
                        pnpm add "plugma@$PLUGMA_VERSION" --ignore-workspace-root-check
                      fi
                    elif [ "$PACKAGE_MANAGER" = "yarn" ]; then
                      echo "üì¶ Using yarn (detected from packageManager field)"
                      # Try with frozen lockfile first, fallback to regular install if it fails
                      if ! yarn install --frozen-lockfile; then
                        echo "‚ö†Ô∏è  Lockfile is out of sync, updating dependencies..."
                        yarn install
                      fi
                    elif [ "$PACKAGE_MANAGER" = "npm" ]; then
                      echo "üì¶ Using npm (detected from packageManager field)"
                      # Try with ci first, fallback to install if it fails
                      if ! npm ci; then
                        echo "‚ö†Ô∏è  Lockfile is out of sync, updating dependencies..."
                        npm install
                      fi
                    else
                      echo "‚ÑπÔ∏è  No packageManager field found or unsupported manager: $PACKAGE_MANAGER"
                      # Fall back to lockfile detection
                      if [ -f "pnpm-lock.yaml" ]; then
                        echo "üì¶ Using pnpm (detected from pnpm-lock.yaml)"
                        if ! pnpm install --frozen-lockfile; then
                          echo "‚ö†Ô∏è  Lockfile is out of sync, updating dependencies..."
                          pnpm install
                        fi

                        # Ensure plugma is installed locally (not linked globally)
                        echo "üì¶ Ensuring plugma is installed locally..."
                        PLUGMA_VERSION=$(grep -o '"plugma": "[^"]*"' package.json | cut -d'"' -f4)
                        if pnpm list plugma | grep -q "link:"; then
                          echo "‚ö†Ô∏è  plugma is linked globally, reinstalling locally..."
                          pnpm remove plugma
                          pnpm add "plugma@$PLUGMA_VERSION" --ignore-workspace-root-check
                        fi
                      elif [ -f "yarn.lock" ]; then
                        echo "üì¶ Using yarn (detected from yarn.lock)"
                        if ! yarn install --frozen-lockfile; then
                          echo "‚ö†Ô∏è  Lockfile is out of sync, updating dependencies..."
                          yarn install
                        fi
                      elif [ -f "package-lock.json" ]; then
                        echo "üì¶ Using npm (detected from package-lock.json)"
                        if ! npm ci; then
                          echo "‚ö†Ô∏è  Lockfile is out of sync, updating dependencies..."
                          npm install
                        fi
                      else
                        echo "‚ùå No lockfile found. Cannot determine package manager."
                        exit 1
                      fi
                    fi
                  else
                    echo "‚ùå package.json not found. Cannot determine package manager."
                    exit 1
                  fi

            - name: Verify package manager selection
              run: |
                  echo "üîç Verifying package manager selection..."

                  # Show which package manager was used
                  if [ -f "package.json" ]; then
                    PACKAGE_MANAGER=$(grep -o '"packageManager": "[^"]*"' package.json | cut -d'"' -f4 | cut -d'@' -f1)
                    echo "üì¶ Package manager from package.json: $PACKAGE_MANAGER"

                    # Check if the package manager is available
                    if [ "$PACKAGE_MANAGER" = "pnpm" ]; then
                      echo "üîß Testing pnpm availability:"
                      pnpm --version || echo "‚ùå pnpm not available"
                    elif [ "$PACKAGE_MANAGER" = "yarn" ]; then
                      echo "üîß Testing yarn availability:"
                      yarn --version || echo "‚ùå yarn not available"
                    elif [ "$PACKAGE_MANAGER" = "npm" ]; then
                      echo "üîß Testing npm availability:"
                      npm --version || echo "‚ùå npm not available"
                    fi
                  fi

                  # Show which lockfiles exist
                  echo "üìã Lockfiles present:"
                  if [ -f "pnpm-lock.yaml" ]; then echo "  ‚úÖ pnpm-lock.yaml"; fi
                  if [ -f "yarn.lock" ]; then echo "  ‚úÖ yarn.lock"; fi
                  if [ -f "package-lock.json" ]; then echo "  ‚úÖ package-lock.json"; fi

            - name: Determine release type and prerelease status
              id: determine_release_type
              run: |
                  TAG_NAME="${{ github.ref }}"
                  TAG_NAME=${TAG_NAME#refs/tags/}  # Strip refs/tags/ from tag
                  NEW_VERSION=$TAG_NAME

                  # Check if the tag contains 'alpha' or 'beta'
                  if [[ $NEW_VERSION == *"-alpha"* || $NEW_VERSION == *"-beta"* ]]; then
                    echo "This is a pre-release version: $NEW_VERSION"
                    echo "IS_PRERELEASE=true" >> $GITHUB_ENV
                  else
                    echo "This is a stable release version: $NEW_VERSION"
                    echo "IS_PRERELEASE=false" >> $GITHUB_ENV
                  fi

                  echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_ENV
                  echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT # Set NEW_VERSION as output for later steps

            - name: Check if tag exists
              run: git tag -l

            - name: Verify dependencies and build environment
              run: |
                  echo "üîç Verifying build environment..."

                  # Check if node_modules exists
                  if [ -d "node_modules" ]; then
                    echo "‚úÖ node_modules directory exists"
                    echo "üìä node_modules size: $(du -sh node_modules | cut -f1)"
                  else
                    echo "‚ùå node_modules directory not found"
                    exit 1
                  fi

                  # Check if package.json exists and has build script
                  if [ -f "package.json" ]; then
                    echo "‚úÖ package.json exists"
                    if grep -q '"build"' package.json; then
                      echo "‚úÖ build script found in package.json"
                    else
                      echo "‚ö†Ô∏è  No build script found in package.json"
                    fi
                  else
                    echo "‚ùå package.json not found"
                    exit 1
                  fi

                  # List installed packages (top level only) using the same package manager detection
                  echo "üì¶ Top-level dependencies:"
                  if [ -f "package.json" ]; then
                    PACKAGE_MANAGER=$(grep -o '"packageManager": "[^"]*"' package.json | cut -d'"' -f4 | cut -d'@' -f1)
                    if [ "$PACKAGE_MANAGER" = "pnpm" ]; then
                      pnpm list --depth=0 || echo "‚ö†Ô∏è  Could not list pnpm dependencies"
                    elif [ "$PACKAGE_MANAGER" = "yarn" ]; then
                      yarn list --depth=0 || echo "‚ö†Ô∏è  Could not list yarn dependencies"
                    elif [ "$PACKAGE_MANAGER" = "npm" ]; then
                      npm list --depth=0 || echo "‚ö†Ô∏è  Could not list npm dependencies"
                    else
                      # Fall back to lockfile detection
                      if [ -f "pnpm-lock.yaml" ]; then
                        pnpm list --depth=0 || echo "‚ö†Ô∏è  Could not list pnpm dependencies"
                      elif [ -f "yarn.lock" ]; then
                        yarn list --depth=0 || echo "‚ö†Ô∏è  Could not list yarn dependencies"
                      elif [ -f "package-lock.json" ]; then
                        npm list --depth=0 || echo "‚ö†Ô∏è  Could not list npm dependencies"
                      fi
                    fi
                  fi

            - name: Verify plugma binary availability
              run: |
                  echo "üîç Verifying plugma availability..."

                  # Check the expected plugma version from package.json
                  if [ -f "package.json" ]; then
                    EXPECTED_VERSION=$(grep -o '"plugma": "[^"]*"' package.json | cut -d'"' -f4)
                    echo "üì¶ Expected plugma version from package.json: $EXPECTED_VERSION"
                  fi

                  # Check if plugma is available (either local or linked)
                  if [ -d "node_modules/plugma" ]; then
                    echo "‚úÖ plugma package found locally in node_modules/plugma"

                    # Check the installed version
                    if [ -f "node_modules/plugma/package.json" ]; then
                      INSTALLED_VERSION=$(grep -o '"version": "[^"]*"' node_modules/plugma/package.json | cut -d'"' -f4)
                      echo "üì¶ Installed plugma version: $INSTALLED_VERSION"
                    fi
                  elif pnpm list plugma | grep -q "link:"; then
                    echo "‚úÖ plugma is linked globally"
                    pnpm list plugma | grep "link:"
                  else
                    echo "‚ùå plugma package not found"
                  fi

                  # Test if the package manager can run the build command
                  echo "üîß Testing package manager build command..."
                  if [ -f "package.json" ]; then
                    PACKAGE_MANAGER=$(grep -o '"packageManager": "[^"]*"' package.json | cut -d'"' -f4 | cut -d'@' -f1)
                    if [ "$PACKAGE_MANAGER" = "pnpm" ]; then
                      echo "üì¶ Testing pnpm run build (dry run):"
                      pnpm run --dry-run build || echo "‚ùå pnpm run build failed"
                    elif [ "$PACKAGE_MANAGER" = "yarn" ]; then
                      echo "üì¶ Testing yarn build (dry run):"
                      yarn build --dry-run || echo "‚ùå yarn build failed"
                    elif [ "$PACKAGE_MANAGER" = "npm" ]; then
                      echo "üì¶ Testing npm run build (dry run):"
                      npm run build --dry-run || echo "‚ùå npm run build failed"
                    fi
                  fi

            - name: Build project
              run: |
                  echo "üî® Building project..."

                  # Use the same package manager detection logic as dependency installation
                  if [ -f "package.json" ]; then
                    PACKAGE_MANAGER=$(grep -o '"packageManager": "[^"]*"' package.json | cut -d'"' -f4 | cut -d'@' -f1)
                    if [ "$PACKAGE_MANAGER" = "pnpm" ]; then
                      echo "üì¶ Building with pnpm..."
                      # Use pnpm run build which should work with linked packages
                      pnpm run build
                    elif [ "$PACKAGE_MANAGER" = "yarn" ]; then
                      echo "üì¶ Building with yarn..."
                      yarn build
                    elif [ "$PACKAGE_MANAGER" = "npm" ]; then
                      echo "üì¶ Building with npm..."
                      npm run build
                    else
                      echo "‚ÑπÔ∏è  No packageManager field found or unsupported manager: $PACKAGE_MANAGER"
                      # Fall back to lockfile detection
                      if [ -f "pnpm-lock.yaml" ]; then
                        echo "üì¶ Building with pnpm (detected from pnpm-lock.yaml)..."
                        pnpm run build
                      elif [ -f "yarn.lock" ]; then
                        echo "üì¶ Building with yarn (detected from yarn.lock)..."
                        yarn build
                      elif [ -f "package-lock.json" ]; then
                        echo "üì¶ Building with npm (detected from package-lock.json)..."
                        npm run build
                      else
                        echo "‚ùå No lockfile found. Cannot determine package manager for build."
                        exit 1
                      fi
                    fi
                  else
                    echo "‚ùå package.json not found. Cannot determine package manager for build."
                    exit 1
                  fi
              continue-on-error: false

            - name: Handle build failure
              if: failure()
              run: |
                  echo "‚ùå Build failed!"
                  echo "üìã Current directory contents:"
                  ls -la

                  echo "üìã package.json contents:"
                  cat package.json || echo "package.json not found"

                  echo "üìã Available scripts:"
                  if [ -f "package.json" ]; then
                    grep -A 10 '"scripts"' package.json || echo "No scripts found"
                  fi

                  echo "‚ùå Exiting due to build failure"
                  exit 1

            - name: Zip dist folder
              run: |
                  echo "üì¶ Creating release archive..."

                  # Check for common build output directories
                  if [ -d "dist" ]; then
                    echo "‚úÖ Found dist directory, creating dist.zip"
                    zip -r dist.zip dist
                  elif [ -d "build" ]; then
                    echo "‚úÖ Found build directory, creating build.zip"
                    zip -r build.zip build
                  elif [ -d "out" ]; then
                    echo "‚úÖ Found out directory, creating out.zip"
                    zip -r out.zip out
                  elif [ -d ".next" ]; then
                    echo "‚úÖ Found .next directory, creating next.zip"
                    zip -r next.zip .next
                  else
                    echo "‚ö†Ô∏è  No common build output directory found. Checking for any directories..."
                    # List all directories to help debug
                    ls -la

                    # Try to find any directory that might be build output
                    for dir in */; do
                      if [ -d "$dir" ] && [ "$dir" != "node_modules/" ] && [ "$dir" != ".git/" ]; then
                        echo "üìÅ Found potential build output: $dir"
                        zip -r "${dir%/}.zip" "$dir"
                        break
                      fi
                    done

                    # If no directories found, create an empty zip or fail
                    if [ ! -f "*.zip" ]; then
                      echo "‚ùå No build output found to zip. Creating empty archive."
                      touch empty.zip
                    fi
                  fi

                  # List created archives
                  echo "üìã Created archives:"
                  ls -la *.zip || echo "No zip files found"

            - name: Determine release asset to upload
              id: determine_asset
              run: |
                  echo "üîç Determining which asset to upload..."

                  # Find the first zip file available
                  if [ -f "dist.zip" ]; then
                    echo "‚úÖ Found dist.zip"
                    echo "ASSET_PATH=./dist.zip" >> $GITHUB_ENV
                    echo "ASSET_NAME=dist.zip" >> $GITHUB_ENV
                  elif [ -f "build.zip" ]; then
                    echo "‚úÖ Found build.zip"
                    echo "ASSET_PATH=./build.zip" >> $GITHUB_ENV
                    echo "ASSET_NAME=build.zip" >> $GITHUB_ENV
                  elif [ -f "out.zip" ]; then
                    echo "‚úÖ Found out.zip"
                    echo "ASSET_PATH=./out.zip" >> $GITHUB_ENV
                    echo "ASSET_NAME=out.zip" >> $GITHUB_ENV
                  elif [ -f "next.zip" ]; then
                    echo "‚úÖ Found next.zip"
                    echo "ASSET_PATH=./next.zip" >> $GITHUB_ENV
                    echo "ASSET_NAME=next.zip" >> $GITHUB_ENV
                  elif [ -f "empty.zip" ]; then
                    echo "‚ö†Ô∏è  Found empty.zip (no build output)"
                    echo "ASSET_PATH=./empty.zip" >> $GITHUB_ENV
                    echo "ASSET_NAME=empty.zip" >> $GITHUB_ENV
                  else
                    echo "‚ùå No zip file found to upload"
                    echo "ASSET_PATH=" >> $GITHUB_ENV
                    echo "ASSET_NAME=" >> $GITHUB_ENV
                  fi

                  echo "Asset path: $ASSET_PATH"
                  echo "Asset name: $ASSET_NAME"

            - name: Extract Release Title and Notes from Tag
              id: extract_tag_message
              run: |
                  TAG_NAME="${{ github.ref }}"
                  TAG_NAME=${TAG_NAME#refs/tags/}
                  TAG_MESSAGE=$(git tag -l --format='%(contents)' $TAG_NAME)

                  # Assuming the first line is the release title, and the rest is release notes
                  # Extract the release title and notes using markers
                  RELEASE_TITLE=$(echo "$TAG_MESSAGE" | sed -n 's/^TITLE: //p')
                  RELEASE_NOTES=$(echo "$TAG_MESSAGE" | sed -n '/^NOTES: /,$p' | sed 's/^NOTES: //')

                  # Fallback if no title or notes are found
                  if [ -z "$RELEASE_TITLE" ]; then
                    RELEASE_TITLE=$TAG_NAME
                  fi

                  if [ -z "$RELEASE_NOTES" ]; then
                    RELEASE_NOTES="No release notes added."
                  fi

                  echo "Tag message is: $TAG_MESSAGE"
                  echo "Release title is: $RELEASE_TITLE"
                  echo "Release notes is: $RELEASE_NOTES"

                  echo "RELEASE_TITLE=$RELEASE_TITLE" >> $GITHUB_ENV
                  echo "RELEASE_NOTES=$RELEASE_NOTES" >> $GITHUB_ENV

            - name: Clear Tag Message with Lightweight Tag
              run: |
                  TAG_NAME="${{ github.ref }}"
                  TAG_NAME=${TAG_NAME#refs/tags/}

                  # Delete the annotated tag locally
                  git tag -d $TAG_NAME

                  # Recreate the tag as a lightweight tag (no message)
                  git tag $TAG_NAME

                  # Force push the updated lightweight tag
                  git push --force origin $TAG_NAME

            - name: Create GitHub Release
              id: create_release
              uses: actions/create-release@v1
              with:
                  tag_name: ${{ env.NEW_VERSION }}
                  release_name: ${{ env.RELEASE_TITLE }}
                  body: ${{ env.RELEASE_NOTES }}
                  draft: false
                  prerelease: ${{ env.IS_PRERELEASE }}
              env:
                  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

            - name: Upload release asset
              if: env.ASSET_PATH != ''
              uses: actions/upload-release-asset@v1
              with:
                  upload_url: ${{ steps.create_release.outputs.upload_url }}
                  asset_path: ${{ env.ASSET_PATH }}
                  asset_name: ${{ env.ASSET_NAME }}
                  asset_content_type: application/zip
              env:
                  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

            - name: Skip asset upload
              if: env.ASSET_PATH == ''
              run: |
                  echo "‚ö†Ô∏è  No asset to upload - skipping asset upload step"
                  echo "This might be expected if the project doesn't generate build artifacts"

    rollback:
        runs-on: ubuntu-latest
        needs: release # Ensures rollback runs only after release job completes
        if: ${{ failure() }} # Check if release job failed
        env:
            NEW_VERSION: ${{ needs.release.outputs.NEW_VERSION }} # Pass the new version from the release step
        steps:
            - name: Checkout repository with full history
              uses: actions/checkout@v3
              with:
                  ref: main # Make sure we are on the main branch
                  fetch-depth: 0 # Fetch all history so we can perform the reset

            - name: Show NEW_VERSION value
              run: |
                  echo "NEW_VERSION is set to: ${{ env.NEW_VERSION }}"

            - name: Reset version bump commit
              run: |
                  echo "Rolling back version bump commit due to workflow failure..."
                  git reset --hard HEAD^1
                  git push origin main --force

            - name: Delete the tag locally
              run: |
                  echo "Deleting tag: ${{ env.NEW_VERSION }}"
                  git tag -d "${{ env.NEW_VERSION }}" # Deletes the tag locally

            - name: Delete the tag on remote
              run: |
                  echo "Deleting remote tag: ${{ env.NEW_VERSION }}"
                  git push origin :refs/tags/${{ env.NEW_VERSION }} # Deletes the tag on the remote
